use UR6;
use UR6::Object;
use UR6::Context;
use UR6::Context::Transaction;
use Test;

plan 4;

class Foo is UR6::Object {
    has Int $.param1;
    has Str $.param2;
}

subtest 'changes outside of transaction' => {
    plan 1;
    my $o = Foo.create(param1 => 1, param2 => 'two');
    ok $o ~~ Failure, 'creating outside of a transaction returns Failure';

    # TODO test that defining an object and changing it throws an exception
}

UR6::Context.branch(UR6::Context::Transaction);

subtest 'create/get/delete' => {
    plan 9;

    my $obj = Foo.create(param1 => 1, param2 => 'two');
    ok $obj, 'Created object';
    my $obj-id = $obj.__id;
    ok $obj-id, 'object has __id';

    my @objects = Foo.get();
    is @objects.elems, 1, 'get() with no params returns the one created object';
    ok @objects[0] === $obj, 'It is the same object we just created';

    @objects = Foo.get(__id => $obj-id);
    is @objects.elems, 1, 'Get 1 object by __id';
    ok @objects[0] === $obj, 'was the same object';

    ok $obj.delete(), 'delete object';
    @objects = Foo.get();
    is @objects.elems, 0, 'get() returned 0 objects';
    ok ! Foo.get(__id => $obj-id), 'get by-id returns nothing';
}

subtest 'get with simple filters' => {
    plan 18;

    ok my $o1 = Foo.create(__id => 'a', param1 => 1, param2 => 'two'),  'create';
    ok my $o2 = Foo.create(__id => 'b', param1 => 1, param2 => 'foo'),  'create';
    ok my $o3 = Foo.create(__id => 'c', param1 => 10, param2 => 'bar'), 'create';
    ok my $o4 = Foo.create(__id => 'd', param1 => 20, param2 => 'bar'), 'create';

    my @results = Foo.get(param1 => 10);
    is @results.elems, 1, 'get() with a filter matches 1 object';
    ok @results[0] === $o3, 'got the right object';

    @results = Foo.get(param2 => 'foo');
    is @results.elems, 1, 'get() with 1 other filter matches 1 object';
    ok @results[0] === $o2, 'got the right other object';

    @results = Foo.get(param1 => 1);
    is @results.elems, 2, 'filter matches 2 objects';
    ok @results>>.__id.contains(all($o1.__id, $o2.__id)), 'Got both objects back';

    @results = Foo.get(param2 => 'bar');
    is @results.elems, 2, 'filter on other property matches 2 objects';
    ok @results>>.__id.contains(all($o3.__id, $o4.__id)), 'Got both objects back';

    @results = Foo.get(param1 => 99);
    is @results.elems, 0, 'filter matching nothing returns 0 objects';

    @results = Foo.get(param1 => 1, param2 => 'foo');
    is @results.elems, 1, 'get() with two filters matched 1 object';
    ok @results[0] === $o2, 'got the right object back';

    @results = Foo.get(param1 => 1);
    is @results.elems, 2, 'get(param1 => 1) returned 2 objects';
    ok @results[0] === $o1, 'First object is o1';
    ok @results[1] === $o2, 'First object is o2';
}

subtest 'id attributes' => {
    plan 14;

    my class SingleId is UR6::Object {
        has $.a is id;
    }

    my $o = SingleId.create(a => 1);
    is $o.__id, 1, 'generated __id from explicit ID property';

    $o = SingleId.create();
    ok $o.__id, 'autgenerated an ID';
    is $o.a, $o.__id, 'autogenerated ID matches explicit ID attribute';

    $o = SingleId.create(__id => 'foo');
    is $o.__id, 'foo', 'passed in __id to create()';
    is $o.a, 'foo', 'value appears in explicit ID attribute';

    throws-like { SingleId.create(a => 1, __id => 1) },
        Exception, message => /'Cannot provide both __id and explicit ID'/;


    my class MultiId is UR6::Object {
        has $.a is id;
        has $.b is id;
    }
    my $both = MultiId.create(a => 1, b => 'b');
    is $both.__id, "1\0b", 'composite ID value';

    my $first = MultiId.create(a => 1);
    is $first.__id, "1\0", 'composite ID value specifying first attribute';

    my $second = MultiId.create(b => 1);
    is $second.__id, "\01", 'composite ID value specifying second attribute';

    my $implicit = MultiId.create(__id => "foo\0bar");
    is $implicit.__id, "foo\0bar", 'implicit ID passed to create()';
    is $implicit.a, 'foo', 'first property extracted from composite id';
    is $implicit.b, 'bar', 'second property extracted from composite id';

    throws-like { MultiId.create() },
        Exception, message => /'multiple ID attributes'/;
    throws-like { MultiId.create(a => 1, __id => 'foo') },
        Exception, message => /'Cannot provide both __id and explicit ID'/;
};

# vim: set syntax=perl6
